Как правило, в Java классы объединяются в пакеты. Пакеты позволяют организовать классы логически в наборы. По умолчанию java уже имеет ряд встроенных пакетов, например, `java.lang`, `java.util`, `java.io` и т.д. Кроме того, пакеты могут иметь вложенные пакеты.

Организация классов в виде пакетов позволяет избежать конфликта имен между классами. Ведь нередки ситуации, когда разработчики называют свои классы одинаковыми именами. Принадлежность к пакету позволяет гарантировать однозначность имен.

Чтобы указать, что класс принадлежит определенному пакету, надо использовать директиву `package`, после которой указывается имя пакета:

```Java 
package pack_name;
```

Как правило, названия пакетов соответствуют физической структуре проекта, то есть организации каталогов, в которых находятся файлы с исходным кодом. А путь к файлам внутри проекта соответствует названию пакета этих файлов. Например, если классы принадлежат пакету mypack, то эти классы помещаются в проекте в папку mypack.

Классы необязательно определять в пакеты. Если для класса пакет не определен, то считается, что данный класс находится в пакете по умолчанию, который не имеет имени.

Например, создадим в папке для исходных файлов каталог study. В нем создадим файл Program.java со следующим кодом:

```Java 
package study;

public class Program{
	public static void main(String[] args) {
		Person tom;
	}
}

class Person{
	String name; //имя
	int age;     //возраст
	void displayInfo(){
		System.out.printlf("Name: %s \tAge: %d\n", name, age);
	}
}
```

### Импорт пакетов и классов

Если нам надо использовать классы из других пакетов, то нам надо подключить эти пакеты и классы. Исключение составляют классы из пакета java.lang (например, `String`), которые подключаются в программу автоматически.

Например, знакомый по прошлым темам класс Scanner находится в пакете java.util, поэтому мы можем получить к нему доступ следующим способом:

```Java
java.util.Scanner in = new java.util.Scanner(System.in);
```

То есть мы указываем полный путь к файлу в пакете при создании его объекта. Однако такое нагромождение имен пакетов не всегда удобно, и в качестве альтернативы мы можем импортировать пакеты и классы в проект с помощью директивы import, которая указывается после директивы package:

```Java 
package study;

import java.util.Scanner; // импорт класса Scanner

public class Program {
    public static void main(String[] args) {
    
        Scanner in = new Scanner(System.in);
        
    }
}
```

Директива `import` указывается в самом начале кода, после чего идет имя подключаемого класса (в данном случае класса Scanner).

В примере выше мы подключили только один класс, однако пакет `java.util` содержит еще множество классов. И чтобы не подключать по отдельности каждый класс, мы можем сразу подключить весь пакет:

```Java
import java.util.*; // импорт всех классов из пакета java.util
```

Теперь мы можем использовать любой класс из пакета java.util.

Возможна ситуация, когда мы используем два класса с одним и тем же названием из двух разных пакетов, например, класс Date имеется и в пакете java.util, и в пакете java.sql. И если нам надо одновременно использовать два этих класса, то необходимо указывать полный путь к этим классам в пакете:

### Статический импорт

В java есть также особая форма импорта - статический импорт. Для этого вместе с директивой `import` используется модификатор `static`:

```Java 
package study;
import static java.lang.System.*;
import static java.lang.Math.*;

public class Program { 

    public static void main(String[] args) {

        double result = sqrt(20);
        out.println(result);

    }
}
```

Здесь происходит статический импорт классов System и Math. Эти классы имеют статические методы. Благодаря операции статического импорта мы можем использовать эти методы без названия класса. Например, писать не `Math.sqrt(20)`, а `sqrt(20)`, так как функция `sqrt()`, которая возвращает квадратный корень числа, является статической. (Позже мы рассмотрим статические члены класса).

То же самое в отношении класса System: в нем определен статический объект `out`, поэтому мы можем его использовать без указания класса.

